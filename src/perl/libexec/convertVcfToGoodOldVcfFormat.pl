#!/usr/bin/env perl

=head1 LICENSE

Copyright (c) 2018 Illumina, Inc.

This file is part of Illumina's Enhanced Artificial Genome Engine (EAGLE),
covered by the "BSD 2-Clause License" (see accompanying LICENSE file)

=head1 NAME

convertVcf.pl

=head1 DIAGNOSTICS

=head2 Exit status

0: successful completion
1: abnormal completion
2: fatal error

=head2 Errors

All error messages are prefixed with "ERROR: ".

=head2 Warnings

All warning messages generated by EAGLE are prefixed with "WARNING: ".

=head1 CONFIGURATION AND ENVIRONMENT

=back

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

All documented features are fully implemented.

Please report problems to Illumina Technical Support (support@illumina.com)

Patches are welcome.

=head1 AUTHOR

Lilian Janin

=cut

use warnings FATAL => 'all';
use strict;
use Cwd qw(abs_path);
use POSIX qw(strftime);
use File::Spec;
use IO::File;
use Carp;

use Pod::Usage;
use Getopt::Long;
use Data::Dumper;


my $VERSION = '@EAGLE_VERSION_FULL@';
my $DEBUG   = '@EAGLE_DEBUG_MODE@';



my $programName = (File::Spec->splitpath(abs_path($0)))[2];
my $programPath = (File::Spec->splitpath(abs_path($0)))[1];
my $Version_text =
    "$programName $VERSION\n"
  . "Copyright (c) 2014 Illumina, Inc.\n";

my $usage =
    "Usage: $programName [options]\n"
  . "\t-i, --input-vcf=PATH         - [input] \t\tpath to the input VCF file\n"
  . "\t-o, --output-vcf=PATH        - [output]\t\tpath to the generated VCF file\n"
  . "\t--help                       - prints usage guide\n"
  . "\t--version                    - prints version information\n"

.<<'EXAMPLES_END';

EXAMPLES:
    (none)

EXAMPLES_END


my $man           = 0;
my $help          = !(scalar @ARGV);
my $version       = 0;
my $inputVcfFile  = undef;
my $outputVcfFile = undef;

my %options = 
(
    'help'           => \$help,
    'input-vcf'      => \$inputVcfFile,
    'output-vcf'     => \$outputVcfFile,
    "version"        => \$version,
    'man'            => \$man
);

my $result = GetOptions(\%options, 
                        'help|?', 'input-vcf|i=s', 'output-vcf|o=s', 'version', 'man')
             or pod2usage(2);

#pod2usage(1)  if $help;  ## move $usage into SYNOPSIS section 
pod2usage(-verbose => 2,  -input => $1) if ($man and $0 =~ /(.*)/);

# display the version info
if ($version) {
    print $Version_text;
    exit(0);
}
# display the help screen
if ($help) {
    print $usage;
    exit(0);
}

if (!defined $inputVcfFile)
{
    croak "ERROR: *** missing option: --input-vcf ***\n       Type \"$programName --help\" for usage.\n";
}
die("ERROR: Unrecognized command-line argument(s): @ARGV")  if (0 < @ARGV);

my $fullInputVcfFile      = abs_path($inputVcfFile);
(-e "$fullInputVcfFile") or croak "ERROR: *** '$fullInputVcfFile' does not exist ***\n";

my $fullOutputVcfFile        = abs_path($outputVcfFile);
(! -e "$fullOutputVcfFile") or croak "ERROR: *** '$fullOutputVcfFile' already exists ***\n";

open VCF_IN,"<$fullInputVcfFile"  or croak "ERROR: *** failed to open '$fullInputVcfFile' ***\n";
open VCF_OUT,">$fullOutputVcfFile"  or croak "ERROR: *** failed to open '$fullOutputVcfFile' ***\n";
while( <VCF_IN> )
{
    chomp;
    if ($_ =~ /^#/ || $_ =~ /^$/)
    {
        print VCF_OUT "$_\n";
        next;
    }
    my @splitLine = split('\t');

    # Clear GT field (and any other, not used by EAGLE)
    $splitLine[8] = "";
    $splitLine[9] = "";

    print VCF_OUT "#$_\n";
    my %hash;
    $hash{$1} = $2 while $splitLine[7] =~ /([[:alpha:]_]+)=([^;]+)/g;

    if ($splitLine[5] eq ".")
    {
        # Removing those "monomorphic reference" (==homref)... dunno why some positions are specifically mentioned in the vcf
        next;
    }
    elsif (defined $hash{OLD_VARIANT})
    {
        # TODO: fix instead of ignoring those
        warn "WARNING: Ignoring line where OLD_VARIANT is defined: $_\n";
        next;
    }
    elsif (!defined $hash{SVTYPE})
    {
        if (defined $hash{END})
        {
            # TODO: fix instead of ignoring those
            warn "WARNING: Ignoring CANVAS line where SVTYPE is not defined: $_\n";
            next;
        }
        else
        {
            print VCF_OUT join("\t",@splitLine) . "\n";
        }
    }
    elsif ($hash{SVTYPE} =~ "DEL")
    {
        my $lastPos = $hash{END};
        my $id = $splitLine[2];
        $splitLine[2] = $id . "_1";
        $splitLine[3] = "N";
        $splitLine[4] = "N\[$splitLine[0]:${lastPos}\[";
        print VCF_OUT join("\t",@splitLine) . "\n";

        my $firstPos = $splitLine[1];
        $splitLine[1] = $lastPos;
        $splitLine[2] = $id . "_2";
        $splitLine[4] = "\]$splitLine[0]:${firstPos}\]N";
        print VCF_OUT join("\t",@splitLine) . "\n";
    }
    elsif ($hash{SVTYPE} =~ "LOH")
    {
        my $lastPos = $hash{END};
        my $id = $splitLine[2];
        $splitLine[2] = $id . "_1";
        $splitLine[3] = "N";
        $splitLine[4] = "N\[$splitLine[0]:${lastPos}\[";
        print VCF_OUT join("\t",@splitLine) . "\n";

        my $firstPos = $splitLine[1];
        $splitLine[1] = $lastPos;
        $splitLine[2] = $id . "_2";
        $splitLine[4] = "\]$splitLine[0]:${firstPos}\]N";
        print VCF_OUT join("\t",@splitLine) . "\n";
    }
    elsif ($hash{SVTYPE} =~ "BND")
    {
        # TODO: fix instead of ignoring those (they don't seem to get paired correctly)
        #TODO print VCF_OUT join("\t",@splitLine) . "\n";
    }
    elsif ($hash{SVTYPE} =~ "INS")
    {
        if ($splitLine[4] =~ "<INS>")
        {
            $splitLine[4] = $splitLine[4] . $hash{LEFT_SVINSSEQ} . $hash{RIGHT_SVINSSEQ};
        }
        else
        {
            print VCF_OUT join("\t",@splitLine) . "\n";
        }
    }
    elsif ($hash{SVTYPE} =~ "DUP")
    {
        my $lastPos = $hash{END};
        my $id = $splitLine[2];
        $splitLine[2] = $id . "_1";
        $splitLine[3] = "N";
        $splitLine[4] = "\]$splitLine[0]:${lastPos}\]N";
        print VCF_OUT join("\t",@splitLine) . "\n";

        my $firstPos = $splitLine[1];
        $splitLine[1] = $lastPos;
        $splitLine[2] = $id . "_2";
        $splitLine[4] = "N\[$splitLine[0]:${firstPos}\[";
        print VCF_OUT join("\t",@splitLine) . "\n";
    }
}
close VCF_IN;
close VCF_OUT;
print "Successfully writen $outputVcfFile\n";