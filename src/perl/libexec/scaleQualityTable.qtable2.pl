#!/usr/bin/env perl

=head1 LICENSE

Copyright (c) 2018 Illumina, Inc.

This file is part of Illumina's Enhanced Artificial Genome Engine (EAGLE),
covered by the "BSD 2-Clause License" (see accompanying LICENSE file)

=head1 NAME

scaleQualityTable.pl

=head1 DIAGNOSTICS

=head2 Exit status

0: successful completion
1: abnormal completion
2: fatal error

=head2 Errors

All error messages are prefixed with "ERROR: ".

=head2 Warnings

All warning messages generated by EAGLE are prefixed with "WARNING: ".

=head1 CONFIGURATION AND ENVIRONMENT

=back

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

All documented features are fully implemented.

Please report problems to Illumina Technical Support (support@illumina.com)

Patches are welcome.

=head1 AUTHOR

Lilian Janin

=cut

use warnings FATAL => 'all';
use strict;
use Cwd qw(abs_path);
use POSIX qw(strftime floor ceil);
use File::Spec;
use IO::File;
use Carp;
use List::Util qw(max);

use Pod::Usage;
use Getopt::Long;
use Data::Dumper;


my $VERSION = '@EAGLE_VERSION_FULL@';
my $DEBUG   = '@EAGLE_DEBUG_MODE@';

my $programName = (File::Spec->splitpath(abs_path($0)))[2];
my $programPath = (File::Spec->splitpath(abs_path($0)))[1];
my $Version_text =
    "$programName $VERSION\n"
  . "Copyright (c) 2014 Illumina, Inc.\n";

my $usage =
    "Usage: $programName [options]\n"
  . "\t-i, --input=PATH             - [input] \tpath to the input quality table\n"
  . "\t-b, --cycles-before=         - [input] \tnumber of cycles in the input\n"
  . "\t-a, --cycles-after=          - [input] \tnumber of requested cycles\n"
  . "\t-o, --output=PATH            - [output]\tpath to the generated file\n"
  . "\t--help                       - prints usage guide\n"
  . "\t--version                    - prints version information\n"

.<<'EXAMPLES_END';

EXAMPLES:
    (none)

EXAMPLES_END


my $man             = 0;
my $help            = !(scalar @ARGV);
my $version         = 0;
my $inFile          = undef;
my $outFile         = undef;
my $cyclesBefore    = 0;
my $requestedCycles = 0;

my %options = 
(
    'help'           => \$help,
    'input'          => \$inFile,
    'output'         => \$outFile,
    'cycles-before'  => \$cyclesBefore,
    'cycles-after'   => \$requestedCycles,
    "version"        => \$version,
    'man'            => \$man
);

my $result = GetOptions(\%options, 
                        'help|?', 'input|i=s', 'output|o=s', 'cycles-before|b=i', 'cycles-after|a=i', 'version|V', 'man')
             or pod2usage(2);

pod2usage(-verbose => 2,  -input => $1) if ($man and $0 =~ /(.*)/);

# display the version info
if ($version) {
    print $Version_text;
    exit(0);
}
# display the help screen
if ($help) {
    print $usage;
    exit(0);
}

if (!defined $inFile)
{
    croak "ERROR: *** missing option: --input ***\n       Type \"$programName --help\" for usage.\n";
}
if (!defined $outFile)
{
    croak "ERROR: *** missing option: --output ***\n       Type \"$programName --help\" for usage.\n";
}
if (!defined $cyclesBefore)
{
    croak "ERROR: *** missing option: --cycles-before ***\n       Type \"$programName --help\" for usage.\n";
}
if (!defined $requestedCycles)
{
    croak "ERROR: *** missing option: --cycles-after ***\n       Type \"$programName --help\" for usage.\n";
}
if ($cyclesBefore < $requestedCycles)
{
    croak "ERROR: --cycles-before should be greater than --cycles-after.\n";
}
die("ERROR: Unrecognized command-line argument(s): @ARGV")  if (0 < @ARGV);

# Variables for stats
my $Q30basesCount = 0;
my $basesCount = 0;
my $mismatchCount = 0;


my $firstLine=1;
my $lastCycle=-1;
open INF,"<$inFile"  or croak "ERROR: *** failed to open '$inFile' ***\n";
open OUTF,">$outFile"  or croak "ERROR: *** failed to open '$outFile' for writing ***\n";
while( <INF> ) {
    my $line = $_;
    chomp;
    if ( $_ =~ /^#/ ) { print OUTF $line; next; }
    if ( $_ =~ /^$/ ) { print OUTF $line; next; }
    if ( $firstLine ) { print OUTF $line; $firstLine=0; next; }

    my @values = split('\t');
    my $cycleBefore = $values[1];
    my $cycleAfter = int(0.5 + $cycleBefore * $requestedCycles / $cyclesBefore);
    if ($cycleAfter != $lastCycle && $cycleAfter <= $requestedCycles) {
        $values[1] = $cycleAfter;
        print OUTF join("\t",@values) . "\n";
        $lastCycle = $cycleAfter;

        # Compute stats: %Q30 bases, %mismatches
        for (my $j=2; $j<@values; $j++) {
            my @qualAndCount = split(':',$values[$j]);
            $basesCount += $qualAndCount[1];
            if ($qualAndCount[0]>=30) {
                $Q30basesCount += $qualAndCount[1];
            }
            my $errorRate = 10**(- $qualAndCount[0] / 10);
            $mismatchCount += $errorRate * $qualAndCount[1];
        }
    }
}
close INF;
close OUTF;

print "basesCount:    " . $basesCount . "\n";
print "Q30basesCount: " . $Q30basesCount . "\n";
print "mismatchCount: " . $mismatchCount . "\n";
print "\%Q30:         " . (100 * $Q30basesCount / $basesCount) . "\n";
print "\%mismatches:  " . (100 * $mismatchCount / $basesCount) . "\n";
